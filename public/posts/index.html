<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Posts | Tien Phat&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - Tien Phat&#39;s blog">
<meta name="author" content="map[email:dtphat414@gmail.com name:Đào Tiến Phát]">
<link rel="canonical" href="//localhost:1313/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fd5566c526ae48aadabd950798a2dc3568536401560eae5caac3765a42a9e7b5.css" integrity="sha256-/VVmxSauSKravZUHmKLcNWhTZAFWDq5cqsN2WkKp57U=" rel="preload stylesheet" as="style">
<link rel="icon" href="//localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="//localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="//localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="//localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="//localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="//localhost:1313/posts/index.xml" title="rss">
<link rel="alternate" hreflang="en" href="//localhost:1313/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
</head>
<body class="list" id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="//localhost:1313/" accesskey="h" title="Tien Phat&#39;s blog (Alt + H)">Tien Phat&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="//localhost:1313/" title="Trang chủ">
                    <span>Trang chủ</span>
                </a>
            </li>
            <li>
                <a href="//localhost:1313/about/" title="Về tôi">
                    <span>Về tôi</span>
                </a>
            </li>
            <li>
                <a href="//localhost:1313/contact/" title="Liên hệ">
                    <span>Liên hệ</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Socket Programming với Java
    </h2>
  </header>
  <div class="entry-content">
    <p>Socket programming là nền tảng cho mọi giao tiếp mạng trong Java. Trong bài viết này, chúng ta sẽ tìm hiểu cách sử dụng Socket API để xây dựng các ứng dụng client-server.
Socket API Overview Java cung cấp hai loại socket chính:
TCP Sockets: Kết nối đáng tin cậy, có thứ tự (java.net.Socket) UDP Sockets: Kết nối không đảm bảo, nhanh (java.net.DatagramSocket) TCP Client-Server Model TCP sử dụng mô hình client-server với kết nối đáng tin cậy.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-20 00:00:00 +0000 UTC'>December 20, 2025</span>&nbsp;·&nbsp;<span>map[email:dtphat414@gmail.com name:Đào Tiến Phát]</span></footer>
  <a class="entry-link" aria-label="post link to Socket Programming với Java" href="//localhost:1313/posts/socket-programming-java/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Xây dựng HTTP Server đơn giản bằng Java
    </h2>
  </header>
  <div class="entry-content">
    <p>HTTP là giao thức nền tảng của World Wide Web. Trong bài viết này, chúng ta sẽ tìm hiểu cách xây dựng một HTTP server đơn giản từ đầu sử dụng Java Socket API.
HTTP Protocol Basics HTTP (Hypertext Transfer Protocol) là giao thức client-server hoạt động theo mô hình request-response. Client gửi HTTP request đến server, server xử lý và trả về HTTP response.
HTTP Request Format Một HTTP request bao gồm:
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-18 00:00:00 +0000 UTC'>December 18, 2025</span>&nbsp;·&nbsp;<span>map[email:dtphat414@gmail.com name:Đào Tiến Phát]</span></footer>
  <a class="entry-link" aria-label="post link to Xây dựng HTTP Server đơn giản bằng Java" href="//localhost:1313/posts/http-server-java/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">WebSocket API trong JavaScript
    </h2>
  </header>
  <div class="entry-content">
    <p>WebSocket cung cấp kết nối hai chiều (full-duplex) giữa client và server, cho phép giao tiếp real-time hiệu quả hơn nhiều so với HTTP polling.
WebSocket vs HTTP HTTP Polling Client liên tục gửi request để kiểm tra dữ liệu mới Tốn băng thông và tài nguyên server Độ trễ cao WebSocket Kết nối persistent hai chiều Server có thể push data đến client Độ trễ thấp, hiệu suất cao Creating WebSocket Connection Client-side JavaScript // Tạo WebSocket connection const ws = new WebSocket(&#39;ws://localhost:8080&#39;); // Connection opened ws.addEventListener(&#39;open&#39;, (event) =&gt; { console.log(&#39;Connected to server&#39;); ws.send(&#39;Hello Server!&#39;); }); // Listen for messages ws.addEventListener(&#39;message&#39;, (event) =&gt; { console.log(&#39;Message from server:&#39;, event.data); }); // Connection closed ws.addEventListener(&#39;close&#39;, (event) =&gt; { console.log(&#39;Disconnected from server&#39;); }); // Error handler ws.addEventListener(&#39;error&#39;, (error) =&gt; { console.error(&#39;WebSocket error:&#39;, error); }); WebSocket Server (Node.js) Sử dụng thư viện ws:
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-15 00:00:00 +0000 UTC'>December 15, 2025</span>&nbsp;·&nbsp;<span>map[email:dtphat414@gmail.com name:Đào Tiến Phát]</span></footer>
  <a class="entry-link" aria-label="post link to WebSocket API trong JavaScript" href="//localhost:1313/posts/websocket-javascript/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Thiết kế RESTful API với Java Spring Boot
    </h2>
  </header>
  <div class="entry-content">
    <p>RESTful API là kiến trúc phổ biến nhất để xây dựng web services. Trong bài viết này, chúng ta sẽ tìm hiểu cách thiết kế và implement RESTful API với Java Spring Boot.
REST Principles REST (Representational State Transfer) dựa trên các nguyên tắc:
Stateless: Mỗi request độc lập, không lưu trạng thái Client-Server: Tách biệt client và server Cacheable: Response có thể được cache Uniform Interface: Interface nhất quán Layered System: Hệ thống theo layer HTTP Methods CRUD Operations GET: Lấy dữ liệu (Read) POST: Tạo mới (Create) PUT: Cập nhật toàn bộ (Update) PATCH: Cập nhật một phần (Partial Update) DELETE: Xóa (Delete) Spring Boot REST Controller Basic Controller @RestController @RequestMapping(&#34;/api/users&#34;) public class UserController { @Autowired private UserService userService; @GetMapping public List&lt;User&gt; getAllUsers() { return userService.findAll(); } @GetMapping(&#34;/{id}&#34;) public ResponseEntity&lt;User&gt; getUserById(@PathVariable Long id) { User user = userService.findById(id); if (user == null) { return ResponseEntity.notFound().build(); } return ResponseEntity.ok(user); } @PostMapping public ResponseEntity&lt;User&gt; createUser(@RequestBody @Valid User user) { User created = userService.create(user); return ResponseEntity .status(HttpStatus.CREATED) .body(created); } @PutMapping(&#34;/{id}&#34;) public ResponseEntity&lt;User&gt; updateUser( @PathVariable Long id, @RequestBody @Valid User user) { User updated = userService.update(id, user); return ResponseEntity.ok(updated); } @DeleteMapping(&#34;/{id}&#34;) public ResponseEntity&lt;Void&gt; deleteUser(@PathVariable Long id) { userService.delete(id); return ResponseEntity.noContent().build(); } } HTTP Status Codes Common Status Codes 200 OK: Request thành công 201 Created: Resource được tạo thành công 204 No Content: Thành công nhưng không có content 400 Bad Request: Request không hợp lệ 401 Unauthorized: Chưa authenticate 403 Forbidden: Không có quyền truy cập 404 Not Found: Resource không tồn tại 500 Internal Server Error: Lỗi server Request/Response DTOs Data Transfer Objects @Data @NoArgsConstructor @AllArgsConstructor public class UserDTO { private Long id; @NotBlank(message = &#34;Name is required&#34;) private String name; @Email(message = &#34;Invalid email format&#34;) private String email; @Size(min = 8, message = &#34;Password must be at least 8 characters&#34;) private String password; } @Data public class UserResponseDTO { private Long id; private String name; private String email; private LocalDateTime createdAt; } Exception Handling Global Exception Handler @RestControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(ResourceNotFoundException.class) public ResponseEntity&lt;ErrorResponse&gt; handleNotFound( ResourceNotFoundException ex) { ErrorResponse error = new ErrorResponse( HttpStatus.NOT_FOUND.value(), ex.getMessage(), LocalDateTime.now() ); return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error); } @ExceptionHandler(MethodArgumentNotValidException.class) public ResponseEntity&lt;ValidationErrorResponse&gt; handleValidation( MethodArgumentNotValidException ex) { Map&lt;String, String&gt; errors = new HashMap&lt;&gt;(); ex.getBindingResult().getFieldErrors().forEach(error -&gt; errors.put(error.getField(), error.getDefaultMessage()) ); ValidationErrorResponse response = new ValidationErrorResponse( HttpStatus.BAD_REQUEST.value(), &#34;Validation failed&#34;, errors ); return ResponseEntity.badRequest().body(response); } } Pagination &amp; Sorting Pageable Endpoints @GetMapping public Page&lt;UserDTO&gt; getUsers( @RequestParam(defaultValue = &#34;0&#34;) int page, @RequestParam(defaultValue = &#34;10&#34;) int size, @RequestParam(defaultValue = &#34;id&#34;) String sortBy, @RequestParam(defaultValue = &#34;asc&#34;) String direction) { Sort sort = direction.equalsIgnoreCase(&#34;desc&#34;) ? Sort.by(sortBy).descending() : Sort.by(sortBy).ascending(); Pageable pageable = PageRequest.of(page, size, sort); return userService.findAll(pageable); } API Versioning URI Versioning @RestController @RequestMapping(&#34;/api/v1/users&#34;) public class UserControllerV1 { // Version 1 implementation } @RestController @RequestMapping(&#34;/api/v2/users&#34;) public class UserControllerV2 { // Version 2 implementation } Authentication &amp; Authorization JWT Authentication @Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http .csrf().disable() .authorizeRequests() .antMatchers(&#34;/api/auth/**&#34;).permitAll() .antMatchers(&#34;/api/admin/**&#34;).hasRole(&#34;ADMIN&#34;) .anyRequest().authenticated() .and() .addFilter(new JwtAuthenticationFilter(authenticationManager())) .addFilter(new JwtAuthorizationFilter(authenticationManager())) .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS); } } API Documentation Swagger/OpenAPI @Configuration @EnableSwagger2 public class SwaggerConfig { @Bean public Docket api() { return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.basePackage(&#34;com.example.api&#34;)) .paths(PathSelectors.any()) .build() .apiInfo(apiInfo()); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(&#34;User API&#34;) .description(&#34;RESTful API for User Management&#34;) .version(&#34;1.0.0&#34;) .build(); } } Best Practices Use Nouns for Resources: /api/users not /api/getUsers Use HTTP Methods Correctly: GET for read, POST for create, etc. Return Appropriate Status Codes: 200, 201, 404, 500, etc. Version Your API: /api/v1/, /api/v2/ Validate Input: Use @Valid and custom validators Handle Errors Gracefully: Consistent error responses Use DTOs: Separate domain models from API models Document Your API: Swagger, OpenAPI, etc. Implement Pagination: For large datasets Security First: Authentication, authorization, HTTPS Kết luận RESTful API design là kỹ năng quan trọng trong phát triển web services. Tuân thủ các best practices sẽ giúp API của bạn dễ sử dụng, maintain, và scale.
</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-12 00:00:00 +0000 UTC'>December 12, 2025</span>&nbsp;·&nbsp;<span>map[email:dtphat414@gmail.com name:Đào Tiến Phát]</span></footer>
  <a class="entry-link" aria-label="post link to Thiết kế RESTful API với Java Spring Boot" href="//localhost:1313/posts/restful-api-spring/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Fetch API và Async/Await trong JavaScript
    </h2>
  </header>
  <div class="entry-content">
    <p>Fetch API là interface hiện đại để thực hiện HTTP requests trong JavaScript. Kết hợp với async/await, nó giúp code bất đồng bộ trở nên dễ đọc và maintain hơn.
Promises Basics Promise States Pending: Đang chờ xử lý Fulfilled: Hoàn thành thành công Rejected: Bị từ chối (lỗi) Creating Promises const myPromise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { const success = true; if (success) { resolve(&#39;Operation successful!&#39;); } else { reject(&#39;Operation failed!&#39;); } }, 1000); }); myPromise .then(result =&gt; console.log(result)) .catch(error =&gt; console.error(error)); Fetch API Basics Simple GET Request fetch(&#39;https://api.example.com/users&#39;) .then(response =&gt; response.json()) .then(data =&gt; console.log(data)) .catch(error =&gt; console.error(&#39;Error:&#39;, error)); POST Request fetch(&#39;https://api.example.com/users&#39;, { method: &#39;POST&#39;, headers: { &#39;Content-Type&#39;: &#39;application/json&#39;, }, body: JSON.stringify({ name: &#39;John Doe&#39;, email: &#39;john@example.com&#39; }) }) .then(response =&gt; response.json()) .then(data =&gt; console.log(&#39;Created:&#39;, data)) .catch(error =&gt; console.error(&#39;Error:&#39;, error)); Async/Await Converting to Async/Await // Traditional Promise chain function getUsers() { return fetch(&#39;https://api.example.com/users&#39;) .then(response =&gt; response.json()) .then(data =&gt; data) .catch(error =&gt; { console.error(&#39;Error:&#39;, error); throw error; }); } // Using async/await async function getUsers() { try { const response = await fetch(&#39;https://api.example.com/users&#39;); const data = await response.json(); return data; } catch (error) { console.error(&#39;Error:&#39;, error); throw error; } } Error Handling Checking Response Status async function fetchUser(id) { try { const response = await fetch(`https://api.example.com/users/${id}`); if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } const user = await response.json(); return user; } catch (error) { console.error(&#39;Failed to fetch user:&#39;, error); throw error; } } Request Configuration Full Fetch Options async function createUser(userData) { const response = await fetch(&#39;https://api.example.com/users&#39;, { method: &#39;POST&#39;, headers: { &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: `Bearer ${token}`, &#39;Accept&#39;: &#39;application/json&#39; }, body: JSON.stringify(userData), mode: &#39;cors&#39;, credentials: &#39;include&#39;, cache: &#39;no-cache&#39; }); return response.json(); } Concurrent Requests Promise.all() Chạy nhiều requests đồng thời:
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-08 00:00:00 +0000 UTC'>December 8, 2025</span>&nbsp;·&nbsp;<span>map[email:dtphat414@gmail.com name:Đào Tiến Phát]</span></footer>
  <a class="entry-link" aria-label="post link to Fetch API và Async/Await trong JavaScript" href="//localhost:1313/posts/fetch-async-await/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">SSL/TLS và HTTPS trong Java
    </h2>
  </header>
  <div class="entry-content">
    <p>SSL/TLS là giao thức bảo mật quan trọng nhất cho network communication. Trong bài viết này, chúng ta sẽ tìm hiểu cách implement SSL/TLS trong Java applications.
SSL vs TLS SSL (Secure Sockets Layer): Phiên bản cũ (đã deprecated) TLS (Transport Layer Security): Phiên bản hiện đại và bảo mật hơn TLS 1.2 và TLS 1.3 là các phiên bản được khuyến nghị sử dụng hiện nay.
How TLS Works TLS Handshake Process Client gửi “Client Hello” với supported cipher suites Server trả về “Server Hello” và certificate Client verify certificate Trao đổi keys sử dụng asymmetric encryption Establish encrypted connection với symmetric encryption Creating SSL/TLS Server HTTPS Server với Java import javax.net.ssl.*; import java.io.*; import java.security.*; public class SecureServer { public static void main(String[] args) throws Exception { // Load keystore KeyStore keyStore = KeyStore.getInstance(&#34;JKS&#34;); FileInputStream keyStoreFile = new FileInputStream(&#34;server.jks&#34;); keyStore.load(keyStoreFile, &#34;password&#34;.toCharArray()); // Create key manager factory KeyManagerFactory kmf = KeyManagerFactory.getInstance(&#34;SunX509&#34;); kmf.init(keyStore, &#34;password&#34;.toCharArray()); // Create SSL context SSLContext sslContext = SSLContext.getInstance(&#34;TLS&#34;); sslContext.init(kmf.getKeyManagers(), null, null); // Create server socket SSLServerSocketFactory sslServerSocketFactory = sslContext.getServerSocketFactory(); SSLServerSocket serverSocket = (SSLServerSocket) sslServerSocketFactory.createServerSocket(8443); System.out.println(&#34;Secure server started on port 8443&#34;); while (true) { SSLSocket clientSocket = (SSLSocket) serverSocket.accept(); handleClient(clientSocket); } } private static void handleClient(SSLSocket socket) throws IOException { BufferedReader in = new BufferedReader( new InputStreamReader(socket.getInputStream())); PrintWriter out = new PrintWriter(socket.getOutputStream(), true); String message = in.readLine(); out.println(&#34;Secure echo: &#34; &#43; message); socket.close(); } } Creating SSL/TLS Client HTTPS Client public class SecureClient { public static void main(String[] args) throws Exception { // Trust all certificates (development only!) TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() { public X509Certificate[] getAcceptedIssuers() { return null; } public void checkClientTrusted(X509Certificate[] certs, String authType) {} public void checkServerTrusted(X509Certificate[] certs, String authType) {} } }; SSLContext sslContext = SSLContext.getInstance(&#34;TLS&#34;); sslContext.init(null, trustAllCerts, new SecureRandom()); SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory(); SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(&#34;localhost&#34;, 8443); PrintWriter out = new PrintWriter(socket.getOutputStream(), true); BufferedReader in = new BufferedReader( new InputStreamReader(socket.getInputStream())); out.println(&#34;Hello Secure Server!&#34;); String response = in.readLine(); System.out.println(&#34;Server response: &#34; &#43; response); socket.close(); } } Certificate Management Generating Self-Signed Certificate # Generate keystore with self-signed certificate keytool -genkeypair \ -alias server \ -keyalg RSA \ -keysize 2048 \ -validity 365 \ -keystore server.jks \ -storepass password \ -keypass password \ -dname &#34;CN=localhost, OU=IT, O=MyCompany, L=City, ST=State, C=US&#34; # Export certificate keytool -exportcert \ -alias server \ -keystore server.jks \ -file server.cer \ -storepass password # Import to truststore keytool -importcert \ -alias server \ -file server.cer \ -keystore truststore.jks \ -storepass password Spring Boot HTTPS Configuration application.properties # HTTPS configuration server.port=8443 server.ssl.enabled=true server.ssl.key-store=classpath:keystore.jks server.ssl.key-store-password=password server.ssl.key-store-type=JKS server.ssl.key-alias=server # TLS version server.ssl.enabled-protocols=TLSv1.2,TLSv1.3 # Cipher suites server.ssl.ciphers=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 Programmatic Configuration @Configuration public class SSLConfig { @Bean public ServletWebServerFactory servletContainer() { TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory() { @Override protected void postProcessContext(Context context) { SecurityConstraint securityConstraint = new SecurityConstraint(); securityConstraint.setUserConstraint(&#34;CONFIDENTIAL&#34;); SecurityCollection collection = new SecurityCollection(); collection.addPattern(&#34;/*&#34;); securityConstraint.addCollection(collection); context.addConstraint(securityConstraint); } }; tomcat.addAdditionalTomcatConnectors(redirectConnector()); return tomcat; } private Connector redirectConnector() { Connector connector = new Connector(&#34;org.apache.coyote.http11.Http11NioProtocol&#34;); connector.setScheme(&#34;http&#34;); connector.setPort(8080); connector.setSecure(false); connector.setRedirectPort(8443); return connector; } } HTTP Client with SSL RestTemplate with SSL @Configuration public class RestTemplateConfig { @Bean public RestTemplate restTemplate() throws Exception { TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -&gt; true; SSLContext sslContext = SSLContexts.custom() .loadTrustMaterial(null, acceptingTrustStrategy) .build(); SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext); CloseableHttpClient httpClient = HttpClients.custom() .setSSLSocketFactory(csf) .build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(); requestFactory.setHttpClient(httpClient); return new RestTemplate(requestFactory); } } Certificate Validation Custom Trust Manager public class CustomTrustManager implements X509TrustManager { private final X509TrustManager defaultTrustManager; public CustomTrustManager() throws Exception { TrustManagerFactory tmf = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm()); tmf.init((KeyStore) null); for (TrustManager tm : tmf.getTrustManagers()) { if (tm instanceof X509TrustManager) { defaultTrustManager = (X509TrustManager) tm; return; } } throw new IllegalStateException(&#34;No X509TrustManager found&#34;); } @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException { // Custom validation logic if (chain.length == 0) { throw new CertificateException(&#34;Certificate chain is empty&#34;); } // Validate certificate dates for (X509Certificate cert : chain) { cert.checkValidity(); } // Delegate to default trust manager defaultTrustManager.checkServerTrusted(chain, authType); } @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException { defaultTrustManager.checkClientTrusted(chain, authType); } @Override public X509Certificate[] getAcceptedIssuers() { return defaultTrustManager.getAcceptedIssuers(); } } Security Best Practices Use Strong Cipher Suites: Chỉ enable các cipher suites mạnh Enable TLS 1.2&#43;: Disable SSLv3, TLS 1.0, TLS 1.1 Validate Certificates: Luôn validate server certificates Use Proper Key Sizes: RSA 2048 bits minimum Certificate Pinning: Pin certificates trong mobile/desktop apps Regular Updates: Update certificates trước khi expire HSTS: Enable HTTP Strict Transport Security Monitor Certificates: Theo dõi expiration dates Common Issues Certificate Errors sun.security.validator.ValidatorException: Certificate chain không hợp lệ javax.net.ssl.SSLHandshakeException: Handshake failed CertificateExpiredException: Certificate đã hết hạn Debugging SSL Issues # Enable SSL debug logging -Djavax.net.debug=ssl,handshake # Check certificate keytool -list -v -keystore keystore.jks Kết luận SSL/TLS là nền tảng bảo mật cho mọi ứng dụng web và network. Hiểu rõ cách implement và configure SSL/TLS trong Java sẽ giúp bạn xây dựng được các ứng dụng an toàn và đáng tin cậy.
</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-05 00:00:00 +0000 UTC'>December 5, 2025</span>&nbsp;·&nbsp;<span>map[email:dtphat414@gmail.com name:Đào Tiến Phát]</span></footer>
  <a class="entry-link" aria-label="post link to SSL/TLS và HTTPS trong Java" href="//localhost:1313/posts/ssl-tls-https/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Xây dựng TCP Server với Node.js
    </h2>
  </header>
  <div class="entry-content">
    <p>Node.js cung cấp Net module mạnh mẽ để xây dựng TCP servers và clients. Trong bài viết này, chúng ta sẽ tìm hiểu cách tạo TCP server với Node.js.
Net Module Overview Net module cung cấp asynchronous network API để tạo stream-based TCP servers và clients.
Basic TCP Server const net = require(&#39;net&#39;); const server = net.createServer((socket) =&gt; { console.log(&#39;Client connected&#39;); socket.on(&#39;data&#39;, (data) =&gt; { console.log(&#39;Received:&#39;, data.toString()); socket.write(`Echo: ${data}`); }); socket.on(&#39;end&#39;, () =&gt; { console.log(&#39;Client disconnected&#39;); }); socket.on(&#39;error&#39;, (err) =&gt; { console.error(&#39;Socket error:&#39;, err); }); }); server.listen(8080, () =&gt; { console.log(&#39;Server listening on port 8080&#39;); }); TCP Client Connecting to Server const net = require(&#39;net&#39;); const client = net.createConnection({ port: 8080 }, () =&gt; { console.log(&#39;Connected to server&#39;); client.write(&#39;Hello Server!&#39;); }); client.on(&#39;data&#39;, (data) =&gt; { console.log(&#39;Server response:&#39;, data.toString()); client.end(); }); client.on(&#39;end&#39;, () =&gt; { console.log(&#39;Disconnected from server&#39;); }); client.on(&#39;error&#39;, (err) =&gt; { console.error(&#39;Connection error:&#39;, err); }); Handling Multiple Clients Connection Pool const net = require(&#39;net&#39;); const connections = new Set(); const server = net.createServer((socket) =&gt; { connections.add(socket); console.log(`Client connected. Total: ${connections.size}`); socket.on(&#39;data&#39;, (data) =&gt; { // Broadcast to all clients const message = data.toString(); connections.forEach((client) =&gt; { if (client !== socket) { client.write(`[Broadcast] ${message}`); } }); }); socket.on(&#39;end&#39;, () =&gt; { connections.delete(socket); console.log(`Client disconnected. Total: ${connections.size}`); }); socket.on(&#39;error&#39;, (err) =&gt; { console.error(&#39;Socket error:&#39;, err); connections.delete(socket); }); }); server.listen(8080); Streaming Data File Transfer Server const net = require(&#39;net&#39;); const fs = require(&#39;fs&#39;); const server = net.createServer((socket) =&gt; { socket.on(&#39;data&#39;, (data) =&gt; { const filename = data.toString().trim(); if (!fs.existsSync(filename)) { socket.write(&#39;ERROR: File not found\n&#39;); socket.end(); return; } const readStream = fs.createReadStream(filename); readStream.on(&#39;data&#39;, (chunk) =&gt; { if (!socket.write(chunk)) { readStream.pause(); } }); socket.on(&#39;drain&#39;, () =&gt; { readStream.resume(); }); readStream.on(&#39;end&#39;, () =&gt; { socket.end(); }); readStream.on(&#39;error&#39;, (err) =&gt; { socket.write(`ERROR: ${err.message}\n`); socket.end(); }); }); }); server.listen(8080); Protocol Implementation Simple Chat Protocol const net = require(&#39;net&#39;); class ChatServer { constructor(port) { this.port = port; this.clients = new Map(); this.server = null; } start() { this.server = net.createServer((socket) =&gt; { this.handleConnection(socket); }); this.server.listen(this.port, () =&gt; { console.log(`Chat server listening on port ${this.port}`); }); } handleConnection(socket) { const clientId = `${socket.remoteAddress}:${socket.remotePort}`; let username = null; socket.write(&#39;Enter your username: &#39;); socket.on(&#39;data&#39;, (data) =&gt; { const message = data.toString().trim(); if (!username) { username = message; this.clients.set(clientId, { socket, username }); this.broadcast(`${username} joined the chat\n`, clientId); socket.write(&#39;Welcome to the chat!\n&#39;); } else { this.broadcast(`${username}: ${message}\n`, clientId); } }); socket.on(&#39;end&#39;, () =&gt; { if (username) { this.broadcast(`${username} left the chat\n`, clientId); this.clients.delete(clientId); } }); socket.on(&#39;error&#39;, (err) =&gt; { console.error(`Error for ${clientId}:`, err); this.clients.delete(clientId); }); } broadcast(message, excludeId) { this.clients.forEach((client, id) =&gt; { if (id !== excludeId) { client.socket.write(message); } }); } } const chatServer = new ChatServer(8080); chatServer.start(); Error Handling Robust Error Handling const net = require(&#39;net&#39;); const server = net.createServer((socket) =&gt; { socket.setTimeout(30000); // 30 second timeout socket.on(&#39;timeout&#39;, () =&gt; { console.log(&#39;Socket timeout&#39;); socket.end(&#39;Connection timeout\n&#39;); }); socket.on(&#39;error&#39;, (err) =&gt; { if (err.code === &#39;ECONNRESET&#39;) { console.log(&#39;Connection reset by client&#39;); } else if (err.code === &#39;EPIPE&#39;) { console.log(&#39;Broken pipe&#39;); } else { console.error(&#39;Socket error:&#39;, err); } }); socket.on(&#39;data&#39;, (data) =&gt; { try { // Process data const message = data.toString(); socket.write(`Processed: ${message}`); } catch (err) { console.error(&#39;Data processing error:&#39;, err); socket.write(&#39;ERROR: Invalid data\n&#39;); } }); }); server.on(&#39;error&#39;, (err) =&gt; { if (err.code === &#39;EADDRINUSE&#39;) { console.error(&#39;Port already in use&#39;); process.exit(1); } else { console.error(&#39;Server error:&#39;, err); } }); server.listen(8080); Performance Optimization Connection Limits const net = require(&#39;net&#39;); const MAX_CONNECTIONS = 100; let activeConnections = 0; const server = net.createServer((socket) =&gt; { if (activeConnections &gt;= MAX_CONNECTIONS) { socket.end(&#39;Server is full. Try again later.\n&#39;); return; } activeConnections&#43;&#43;; console.log(`Active connections: ${activeConnections}`); socket.on(&#39;end&#39;, () =&gt; { activeConnections--; }); socket.on(&#39;error&#39;, () =&gt; { activeConnections--; }); // Handle socket... }); server.listen(8080); Backpressure Handling socket.on(&#39;data&#39;, (data) =&gt; { const canContinue = socket.write(data); if (!canContinue) { // Buffer is full, pause reading socket.pause(); socket.once(&#39;drain&#39;, () =&gt; { // Buffer drained, resume reading socket.resume(); }); } }); SSL/TLS Support TLS Server const tls = require(&#39;tls&#39;); const fs = require(&#39;fs&#39;); const options = { key: fs.readFileSync(&#39;server-key.pem&#39;), cert: fs.readFileSync(&#39;server-cert.pem&#39;) }; const server = tls.createServer(options, (socket) =&gt; { console.log(&#39;Secure connection established&#39;); socket.write(&#39;Welcome to secure server\n&#39;); socket.on(&#39;data&#39;, (data) =&gt; { socket.write(`Secure echo: ${data}`); }); }); server.listen(8443, () =&gt; { console.log(&#39;TLS server listening on port 8443&#39;); }); Metrics and Monitoring Connection Statistics const net = require(&#39;net&#39;); class MonitoredServer { constructor(port) { this.port = port; this.stats = { totalConnections: 0, activeConnections: 0, bytesReceived: 0, bytesSent: 0 }; } start() { const server = net.createServer((socket) =&gt; { this.stats.totalConnections&#43;&#43;; this.stats.activeConnections&#43;&#43;; socket.on(&#39;data&#39;, (data) =&gt; { this.stats.bytesReceived &#43;= data.length; }); const originalWrite = socket.write.bind(socket); socket.write = (data, ...args) =&gt; { this.stats.bytesSent &#43;= data.length; return originalWrite(data, ...args); }; socket.on(&#39;end&#39;, () =&gt; { this.stats.activeConnections--; }); }); server.listen(this.port); // Log stats every 10 seconds setInterval(() =&gt; { console.log(&#39;Server Stats:&#39;, this.stats); }, 10000); } } const server = new MonitoredServer(8080); server.start(); Best Practices Handle All Events: data, end, error, timeout Set Timeouts: Prevent hanging connections Limit Connections: Protect against resource exhaustion Handle Backpressure: Use pause/resume for flow control Validate Input: Always validate incoming data Use TLS: Encrypt sensitive communication Log Errors: Comprehensive error logging Monitor Performance: Track connections and throughput Kết luận Node.js Net module cung cấp API mạnh mẽ để xây dựng TCP servers. Với event-driven architecture, Node.js rất phù hợp cho các ứng dụng network có nhiều concurrent connections.
</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-01 00:00:00 +0000 UTC'>December 1, 2025</span>&nbsp;·&nbsp;<span>map[email:dtphat414@gmail.com name:Đào Tiến Phát]</span></footer>
  <a class="entry-link" aria-label="post link to Xây dựng TCP Server với Node.js" href="//localhost:1313/posts/tcp-server-nodejs/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Thiết kế Custom Network Protocol
    </h2>
  </header>
  <div class="entry-content">
    <p>Khi HTTP hoặc các protocols chuẩn không đáp ứng được requirements, bạn có thể thiết kế custom protocol riêng. Bài viết này sẽ hướng dẫn cách thiết kế protocol hiệu quả.
Why Custom Protocols? Use Cases Gaming: Low latency, high frequency updates IoT: Bandwidth constraints, custom requirements Financial Systems: High performance, custom message formats Industrial Control: Specialized communication needs Protocol Design Principles Key Considerations Efficiency: Minimize overhead và bandwidth Reliability: Error detection và recovery Extensibility: Support future changes Security: Authentication và encryption Simplicity: Easy to implement và debug Message Format Design Binary vs Text Binary Protocol:
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-11-28 00:00:00 +0000 UTC'>November 28, 2025</span>&nbsp;·&nbsp;<span>map[email:dtphat414@gmail.com name:Đào Tiến Phát]</span></footer>
  <a class="entry-link" aria-label="post link to Thiết kế Custom Network Protocol" href="//localhost:1313/posts/custom-network-protocol/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">RPC và gRPC trong Microservices
    </h2>
  </header>
  <div class="entry-content">
    <p>RPC (Remote Procedure Call) cho phép gọi hàm trên remote server như thể gọi hàm local. gRPC là RPC framework hiện đại từ Google, sử dụng HTTP/2 và Protocol Buffers.
RPC Concepts Traditional RPC vs REST RPC:
Gọi hàm remote như local function Strongly typed với code generation Binary protocols (hiệu quả hơn) REST:
Resource-oriented HTTP methods (GET, POST, PUT, DELETE) Text-based (JSON, XML) gRPC Overview Key Features HTTP/2: Multiplexing, server push, header compression Protocol Buffers: Efficient binary serialization Streaming: Client, server, và bidirectional streaming Code Generation: Tự động generate client/server code Multi-language: Support nhiều ngôn ngữ Protocol Buffers Defining Messages syntax = &#34;proto3&#34;; package user; service UserService { rpc GetUser(GetUserRequest) returns (User); rpc ListUsers(ListUsersRequest) returns (stream User); rpc CreateUser(CreateUserRequest) returns (User); rpc UpdateUser(UpdateUserRequest) returns (User); rpc DeleteUser(DeleteUserRequest) returns (Empty); } message User { int64 id = 1; string name = 2; string email = 3; int32 age = 4; } message GetUserRequest { int64 id = 1; } message ListUsersRequest { int32 page = 1; int32 page_size = 2; } message CreateUserRequest { string name = 1; string email = 2; int32 age = 3; } message UpdateUserRequest { int64 id = 1; string name = 2; string email = 3; int32 age = 4; } message DeleteUserRequest { int64 id = 1; } message Empty {} gRPC Server Implementation Java Server public class UserServiceImpl extends UserServiceGrpc.UserServiceImplBase { @Override public void getUser(GetUserRequest request, StreamObserver&lt;User&gt; responseObserver) { long userId = request.getId(); // Fetch user from database User user = userRepository.findById(userId); if (user != null) { responseObserver.onNext(user); responseObserver.onCompleted(); } else { responseObserver.onError( Status.NOT_FOUND .withDescription(&#34;User not found&#34;) .asRuntimeException() ); } } @Override public void listUsers(ListUsersRequest request, StreamObserver&lt;User&gt; responseObserver) { int page = request.getPage(); int pageSize = request.getPageSize(); List&lt;User&gt; users = userRepository.findAll(page, pageSize); for (User user : users) { responseObserver.onNext(user); } responseObserver.onCompleted(); } @Override public void createUser(CreateUserRequest request, StreamObserver&lt;User&gt; responseObserver) { User user = User.newBuilder() .setName(request.getName()) .setEmail(request.getEmail()) .setAge(request.getAge()) .build(); User created = userRepository.save(user); responseObserver.onNext(created); responseObserver.onCompleted(); } } // Start server public class GrpcServer { public static void main(String[] args) throws IOException, InterruptedException { Server server = ServerBuilder.forPort(9090) .addService(new UserServiceImpl()) .build() .start(); System.out.println(&#34;Server started on port 9090&#34;); server.awaitTermination(); } } gRPC Client Java Client public class UserServiceClient { private final UserServiceGrpc.UserServiceBlockingStub blockingStub; private final UserServiceGrpc.UserServiceStub asyncStub; public UserServiceClient(Channel channel) { this.blockingStub = UserServiceGrpc.newBlockingStub(channel); this.asyncStub = UserServiceGrpc.newStub(channel); } public User getUser(long id) { GetUserRequest request = GetUserRequest.newBuilder() .setId(id) .build(); try { return blockingStub.getUser(request); } catch (StatusRuntimeException e) { logger.log(Level.WARNING, &#34;RPC failed: {0}&#34;, e.getStatus()); return null; } } public void listUsers(int page, int pageSize) { ListUsersRequest request = ListUsersRequest.newBuilder() .setPage(page) .setPageSize(pageSize) .build(); Iterator&lt;User&gt; users = blockingStub.listUsers(request); while (users.hasNext()) { User user = users.next(); System.out.println(&#34;User: &#34; &#43; user.getName()); } } public static void main(String[] args) { ManagedChannel channel = ManagedChannelBuilder .forAddress(&#34;localhost&#34;, 9090) .usePlaintext() .build(); UserServiceClient client = new UserServiceClient(channel); User user = client.getUser(1); System.out.println(&#34;Found user: &#34; &#43; user); channel.shutdown(); } } Streaming RPCs Server Streaming @Override public void streamUsers(StreamRequest request, StreamObserver&lt;User&gt; responseObserver) { userRepository.findAll().forEach(user -&gt; { responseObserver.onNext(user); try { Thread.sleep(100); // Simulate delay } catch (InterruptedException e) { Thread.currentThread().interrupt(); } }); responseObserver.onCompleted(); } Client Streaming @Override public StreamObserver&lt;CreateUserRequest&gt; batchCreateUsers( StreamObserver&lt;BatchCreateResponse&gt; responseObserver) { return new StreamObserver&lt;CreateUserRequest&gt;() { private int count = 0; @Override public void onNext(CreateUserRequest request) { User user = createUser(request); count&#43;&#43;; } @Override public void onError(Throwable t) { logger.log(Level.WARNING, &#34;Error: {0}&#34;, t); } @Override public void onCompleted() { BatchCreateResponse response = BatchCreateResponse.newBuilder() .setCount(count) .build(); responseObserver.onNext(response); responseObserver.onCompleted(); } }; } Bidirectional Streaming @Override public StreamObserver&lt;ChatMessage&gt; chat( StreamObserver&lt;ChatMessage&gt; responseObserver) { return new StreamObserver&lt;ChatMessage&gt;() { @Override public void onNext(ChatMessage message) { // Broadcast to all connected clients broadcastMessage(message, responseObserver); } @Override public void onError(Throwable t) { logger.log(Level.WARNING, &#34;Chat error: {0}&#34;, t); } @Override public void onCompleted() { responseObserver.onCompleted(); } }; } Error Handling gRPC Status Codes public class ErrorHandler { public static StatusRuntimeException notFound(String message) { return Status.NOT_FOUND .withDescription(message) .asRuntimeException(); } public static StatusRuntimeException invalidArgument(String message) { return Status.INVALID_ARGUMENT .withDescription(message) .asRuntimeException(); } public static StatusRuntimeException internal(String message) { return Status.INTERNAL .withDescription(message) .asRuntimeException(); } } // Usage if (user == null) { throw ErrorHandler.notFound(&#34;User not found&#34;); } Interceptors Server Interceptor public class LoggingInterceptor implements ServerInterceptor { @Override public &lt;ReqT, RespT&gt; ServerCall.Listener&lt;ReqT&gt; interceptCall( ServerCall&lt;ReqT, RespT&gt; call, Metadata headers, ServerCallHandler&lt;ReqT, RespT&gt; next) { logger.info(&#34;Method: &#34; &#43; call.getMethodDescriptor().getFullMethodName()); logger.info(&#34;Headers: &#34; &#43; headers); return next.startCall(call, headers); } } // Add to server Server server = ServerBuilder.forPort(9090) .addService(new UserServiceImpl()) .intercept(new LoggingInterceptor()) .build(); Client Interceptor public class AuthInterceptor implements ClientInterceptor { private final String token; @Override public &lt;ReqT, RespT&gt; ClientCall&lt;ReqT, RespT&gt; interceptCall( MethodDescriptor&lt;ReqT, RespT&gt; method, CallOptions callOptions, Channel next) { return new ForwardingClientCall.SimpleForwardingClientCall&lt;ReqT, RespT&gt;( next.newCall(method, callOptions)) { @Override public void start(Listener&lt;RespT&gt; responseListener, Metadata headers) { headers.put(Metadata.Key.of(&#34;authorization&#34;, ASCII_STRING_MARSHALLER), &#34;Bearer &#34; &#43; token); super.start(responseListener, headers); } }; } } Load Balancing Client-Side Load Balancing ManagedChannel channel = ManagedChannelBuilder .forTarget(&#34;dns:///my-service:9090&#34;) .defaultLoadBalancingPolicy(&#34;round_robin&#34;) .usePlaintext() .build(); Security TLS/SSL // Server with TLS Server server = NettyServerBuilder.forPort(9090) .addService(new UserServiceImpl()) .useTransportSecurity(certChainFile, privateKeyFile) .build(); // Client with TLS ManagedChannel channel = NettyChannelBuilder .forAddress(&#34;localhost&#34;, 9090) .sslContext(GrpcSslContexts.forClient() .trustManager(trustCertCollectionFile) .build()) .build(); Spring Boot Integration gRPC Server with Spring Boot @GrpcService public class UserGrpcService extends UserServiceGrpc.UserServiceImplBase { @Autowired private UserRepository userRepository; @Override public void getUser(GetUserRequest request, StreamObserver&lt;User&gt; responseObserver) { // Implementation } } // application.yml grpc: server: port: 9090 Best Practices Use Protocol Buffers: Efficient serialization Implement Timeouts: Prevent hanging calls Handle Errors Properly: Use appropriate status codes Enable Compression: Reduce network usage Use Interceptors: Logging, authentication, metrics Connection Pooling: Reuse connections Health Checks: Monitor service health Versioning: Plan for API evolution Load Balancing: Distribute load across instances TLS: Encrypt communication in production Kết luận gRPC là framework mạnh mẽ cho service-to-service communication trong microservices. Với HTTP/2, Protocol Buffers, và streaming support, gRPC cung cấp hiệu suất và tính năng vượt trội so với REST cho internal APIs.
</p>
  </div>
  <footer class="entry-footer"><span title='2025-11-25 00:00:00 +0000 UTC'>November 25, 2025</span>&nbsp;·&nbsp;<span>map[email:dtphat414@gmail.com name:Đào Tiến Phát]</span></footer>
  <a class="entry-link" aria-label="post link to RPC và gRPC trong Microservices" href="//localhost:1313/posts/rpc-grpc-microservices/"></a>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="//localhost:1313/">Tien Phat&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
